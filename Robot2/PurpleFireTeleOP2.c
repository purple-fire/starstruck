#pragma config(Sensor, in1,    POT,            sensorPotentiometer)
#pragma config(Sensor, in2,    POTCLAW,        sensorPotentiometer)
#pragma config(Sensor, in4,    Gyro,           sensorGyro)
#pragma config(Sensor, dgtl9,  RightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl11, LeftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  OneIndicator,   sensorLEDtoVCC)
#pragma config(Sensor, dgtl6,  TwoIndicator,   sensorLEDtoVCC)
#pragma config(Sensor, dgtl7,  ThreeIndicator, sensorLEDtoVCC)
#pragma config(Sensor, dgtl8,  FourIndicator,  sensorLEDtoVCC)
#pragma config(Motor,  port1,           BL,            tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           FL,            tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           FR,            tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port4,           LARMA,         tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port5,           LARMB,         tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port6,           CLAWA,         tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port7,           CLAWB,         tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port8,           RARMA,         tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port9,           RARMB,         tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port10,          BR,            tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)
//Competition Control and Duration Settings
#pragma competitionControl(OFF)
//#pragma competitionControl(Competition)
#pragma autonomousDuration(60)
#pragma userControlDuration(60)
#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!


///////////
//Defines//
///////////

#define	SUPERLOOP_TICK									10
#define MAX_POWER_OUT										127
#define MIN_POWER_OUT								  	-127
#define STOP														0

#define LIFT_UP_BUTTON									Btn6U
#define LIFT_DOWN_BUTTON								Btn6D
#define CLAW_CLOSE_BUTTON								Btn5D
#define CLAW_OPEN_BUTTON								Btn5U

#define TALL_FENCE_BUTTON								Btn8U
#define SHORT_FENCE_BUTTON							Btn8R

#define AUTORELEASE_OFF_BUTTON					Btn7L
#define AUTORELEASE_ON_BUTTON						Btn7R

#define RIGHT_FORWARD_CHANNEL						vexRT[Ch2]
#define LEFT_FORWARD_CHANNEL						vexRT[Ch3]
#define RIGHT_SIDE_CHANNEL							vexRT[Ch1]
#define LEFT_SIDE_CHANNEL								vexRT[Ch4]

////////////////
//Positions   //
////////////////

#define clawOpen 1345
#define clawClose 5705
#define armDown 19
#define armUp 840
#define armChuck 1900

////////////////
//Lift Control//
////////////////

int actualLiftAngle;
int desiredLiftAngle;
int liftPowerOut;
int errorLiftAngle;
bool liftToggle;

////////////////
//Claw Control//
////////////////

int actualClawAngle;
int desiredClawAngle;
int clawPowerOut;
int errorClawAngle;
bool clawToggle;

//////////////////////////
//Autonomous Positioning//
//////////////////////////

bool straightDrive;
int driveConstant;
int presentGyroPosition;
int setGyroPosition;
int gyroError;
int rightDrivePowerOut;
int leftDrivePowerOut;

///////////////
//AutoRelease//
///////////////

int presentLiftAngle;
int previousLiftAngle;
int liftSpeed;
int autoReleasePoint;

bool fourStars;
bool threeStars;
bool twoStars;
bool oneStar;
bool autoReleaseToggle = true;


/////////////////////
//Functions Library//
/////////////////////

////////////////////////////////////////////////////////////////////////////////////////////
void SetClawAngle(int clawAngle)																													//
{																																													//
	hogCPU();																																								//
	desiredClawAngle = clawAngle;																														//
	releaseCPU();																																						//
}																																													//
////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////
void SetLiftAngle(int liftAngle)																													//
{																																													//
	hogCPU();																																								//
	desiredLiftAngle = liftAngle;																														//
	releaseCPU();																																						//
}																																													//
////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////
void DriveForward(int power, int position, int gyroSet)																		//
{																																													//
	SensorValue[RightEncoder] = 0;																													//
	SensorValue[LeftEncoder] = 0;																														//
	//
	setGyroPosition = gyroSet;																															//
	//
	straightDrive = true;																																		//
	//
	driveConstant = power;																																	//
	//
	while(SensorValue[RightEncoder] < position)																							//
	{																																												//
	}																																												//
	//
	straightDrive = false;																																	//
	//
	motor[BL] = -10;																																			   	//
	motor[FL] = -10;																																					//
	motor[BR] = -10;																																					//
	motor[FR] = -10;																																					//
}																																													//
////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////
void DriveBackwardsE(int power, int position, int gyroSet)																//
{																																													//
	SensorValue[RightEncoder] = 0;																													//
	SensorValue[LeftEncoder] = 0;																														//
	//
	setGyroPosition = gyroSet;																															//
	//
	straightDrive = true;																																		//
	//
	driveConstant = (-1 * power);																														//
	//
	while(SensorValue[RightEncoder] > (-1 * position))																			//
	{																																												//
	}																																												//
	//
	straightDrive = false;																																	//
	//
	motor[BL] = 10;																																					//
	motor[FL] = 10;																																					//
	motor[BR] = 10;																																					//
	motor[FR] = 10;																																					//
}																																													//
////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////
void DriveBackwardsT(int power, int waitTime)																							//
{																																													//
	SensorValue[RightEncoder] = 0;																													//
	SensorValue[LeftEncoder] = 0;																														//
	//
	//
	straightDrive = false;																																	//
	//
	motor[BL] = (-1 * power);																																//
	motor[FL] = (-1 * power);																																//
	motor[BR] = (-1 * power);																																//
	motor[FR] = (-1 * power);																																//
	//
	wait1Msec(waitTime);																																		//
	//
	straightDrive = false;																																	//
	//
	motor[BL] = 10;																																					//
	motor[FL] = 10;																																					//
	motor[BR] = 10;																																					//
	motor[FR] = 10;																																					//
}																																													//
////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////
void TurnRight(int power, int position)
{
	SensorValue[RightEncoder] = 0;
	SensorValue[LeftEncoder] = 0;
	straightDrive = false;
	motor[BL] = power;
	motor[FL] = power;
	motor[BR] = (-1 * power);
	motor[FR] = (-1 * power);
	while(SensorValue[Gyro] < position)
	{
	}
	motor[BL] = -10;
	motor[FL] = -10;
	motor[BR] = 10;
	motor[FR] = 10;
}
////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////
void TurnLeft(int power, int position)
{
	SensorValue[RightEncoder] = 0;
	SensorValue[LeftEncoder] = 0;
	straightDrive = false;
	motor[BL] = (-1 * power);
	motor[FL] = (-1 * power);
	motor[BR] = power;
	motor[FR] = power;
	while(SensorValue[Gyro] > position)
	{
	}
	motor[BL] = 10;
	motor[FL] = 10;
	motor[BR] = -10;
	motor[FR] = -10;
}
////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////
int limitMotorPower(int power)																														//
{																																													//
	int	outputPower;																																				//
	//
	outputPower = power;																																		//
	if(outputPower > MAX_POWER_OUT)																													//
	{																																												//
		outputPower = MAX_POWER_OUT;																													//
	}																																												//
	else if(outputPower < MIN_POWER_OUT)																										//
	{																																												//
		outputPower = MIN_POWER_OUT;																													//
	}																																												//
	return(outputPower);																																		//
}																																													//
////////////////////////////////////////////////////////////////////////////////////////////

void AssignDrive(int BLPower, int BRPower, int FLPower, int FRPower)
{
	motor[BL] = BLPower;
	motor[BR] = BRPower;
	motor[FL] = FLPower;
	motor[FR] = FRPower;
}

void AssignLift(int BLLPower, int BRLPower, int LLPower, int RLPower)
{
	motor[LARMB] = BLLPower;
	motor[RARMB] = BRLPower;
	motor[LARMA] = LLPower;
	motor[RARMA] = RLPower;
}

void stopBot(){
	motor[BL] = 0;																																			   	//
	motor[FL] = 0;																																					//
	motor[BR] = 0;																																					//
	motor[FR] = 0;																																					//
}
/////////
//Tasks//
/////////

task StraightDriveControl();
task AutoReleaseControl();
task AutonLiftControl();
task AutonClawControl();
task LiftControl();
task ClawControl();
task DriveControl();
task IndicatorControl();

/////////////////////////////////////////////////////////////////////////////////////////
//																																										 //
//                          Pre-Autonomous Functions																	 //
//																																										 //
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
}




/////////////////////////////////////////////////////////////////////////////////////////
//																																										 //
//                                 Autonomous Task																		 //
//																																										 //
/////////////////////////////////////////////////////////////////////////////////////////

/////////////////////
//Autonomous Skills//
/////////////////////

//task usercontrol()
task autonomous
{
	//start tasks
	startTask(StraightDriveControl);
	startTask(AutoReleaseControl);
	startTask(IndicatorControl);
	startTask(AutonClawControl);
	startTask(AutonLiftControl);

	desiredClawAngle = SensorValue[POTCLAW];
	desiredLiftAngle = SensorValue[POT];

	//enable toggles
	liftToggle = true;
	clawToggle = true;
	autoReleaseToggle = true;

	//reset gyro
	SensorValue[Gyro] = 0;

	//open claw and midfield drive
	SetClawAngle(clawOpen);
	DriveForward(100, 500, 0);

	//turn towards cube
	TurnRight(100, 700);

	wait1Msec(200);

	//drive into cube
	DriveForward(100, 500, 800);

	//start claw close
	clawToggle = false;
	motor[CLAWA] = -127;
	motor[CLAWB] = -127;

	//finish cube drive
	DriveForward(100, 150, 800);

	//lift cube
	SetLiftAngle(1600);

	//wait for lift to move and enable claw control
	while(SensorValue[POT] < 1000)
	{
	}
	motor[CLAWA] = 0;
	motor[CLAWB] = 0;
	clawToggle = true;
	SetClawAngle(SensorValue[POTCLAW] - 100);

	//back up to prep for throw
	DriveBackwardsE(100, 600, 800);

	wait1Msec(500);

	//turn to throw
	TurnRight(70, 1450);

	//back up to throw field cube
	DriveBackwardsE(100, 200, 1690);
	//throw cube
	SetLiftAngle(2650);
	//finish back drive
	DriveBackwardsT(127, 980);
	//drop lift
	SetLiftAngle(armDown);
	//wait for lift to lower
	while(SensorValue[POT] > 900)
	{
	}

	//drive into first load
	DriveForward(100, 850, 1660);

	//grab first load
	clawToggle = false;
	motor[CLAWA] = -127;
	motor[CLAWB] = -127;

	//finish cube drive
	DriveForward(100, 150, 1700);

	//lift cube
	SetLiftAngle(1600);

	//wait for lift to move and enable claw control
	while(SensorValue[POT] < 1000)
	{
	}
	motor[CLAWA] = 0;
	motor[CLAWB] = 0;
	clawToggle = true;
	SetClawAngle(SensorValue[POTCLAW] - 100);


	//lift first load and back up
	SetLiftAngle(1800);
	DriveBackwardsE(100, 300, 1694);
	while(SensorValue[POT] < 1000)
	{
	}
	//back up to throw
	DriveBackwardsE(100, 310, 1694);
	//throw
	SetLiftAngle(2650);
	//finish back drive
	DriveBackwardsT(127, 980);

	//drop lift
	SetLiftAngle(armDown);
	//wait for lift to lower
	while(SensorValue[POT] > 900)
	{
	}

	//drive second load
	DriveForward(100, 575, 1694);

	//grab second load
	clawToggle = false;
	motor[CLAWA] = -127;
	motor[CLAWB] = -127;

	//finish second drive
	DriveForward(100, 150, 1694);

	//lift cube
	SetLiftAngle(1600);

	//wait for lift to move and enable claw control
	while(SensorValue[POT] < 1000)
	{
	}
	motor[CLAWA] = 0;
	motor[CLAWB] = 0;
	clawToggle = true;
	SetClawAngle(SensorValue[POTCLAW] - 100);


	//lift second load and back up
	SetLiftAngle(1800);
	DriveBackwardsE(100, 275, 1694);
	while(SensorValue[POT] < 1000)
	{
	}
	//back up to throw
	DriveBackwardsE(100, 310, 1694);
	//throw
	SetLiftAngle(2650);
	//finish back drive
	DriveBackwardsT(100, 1694);

	//drop lift
	SetLiftAngle(armDown);
	//wait for lift to lower
	while(SensorValue[POT] > 800)
	{
	}

	//drive third load
	DriveForward(100, 725, 1694);

	//grab third load
	clawToggle = false;
	motor[CLAWA] = -127;
	motor[CLAWB] = -127;

	//finish third drive
	DriveForward(100, 150, 1694);

	//lift cube
	SetLiftAngle(1600);

	//wait for lift to move and enable claw control
	while(SensorValue[POT] < 1000)
	{
	}
	motor[CLAWA] = 0;
	motor[CLAWB] = 0;
	clawToggle = true;
	SetClawAngle(SensorValue[POTCLAW] - 100);


	//lift third load and back up
	SetLiftAngle(1800);
	DriveBackwardsE(100, 300, 1694);
	while(SensorValue[POT] < 1000)
	{
	}
	//back up to throw
	DriveBackwardsE(100, 280, 1694);
	//throw
	SetLiftAngle(2650);
	//finish back drive
	DriveBackwardsT(127, 1694);

	//drop lift
	SetLiftAngle(armDown);
	//wait for lift to lower
	while(SensorValue[POT] > 800)
	{
	}

	stopBot();
	while(true)
	{
		wait1Msec(20);
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
//																																										 //
//                                 User Control																				 //
//																																										 //
/////////////////////////////////////////////////////////////////////////////////////////
task usercontrol()
//task autonomous()
{
	desiredClawAngle = SensorValue[POTCLAW];
	desiredLiftAngle = SensorValue[POT];
	startTask(AutoReleaseControl);
	startTask(IndicatorControl);
	startTask(AutonLiftControl);
	startTask(AutonClawControl);
	startTask(LiftControl);
	startTask(ClawControl);
	startTask(DriveControl);
	//open claw and midfield drive
	SetClawAngle(clawOpen);
	while(true)
	{
		wait1Msec(SUPERLOOP_TICK);
	}
}

task StraightDriveControl()
{
	while(true)
	{
		if(straightDrive == true)
		{
			hogCPU();
			presentGyroPosition = SensorValue[Gyro];

			gyroError = (setGyroPosition - presentGyroPosition);

			rightDrivePowerOut = ((-gyroError * 0.5) + driveConstant);
			leftDrivePowerOut = ((-1 * (-gyroError * 0.5)) + driveConstant);

			motor[BL] = leftDrivePowerOut;
			motor[FL] = leftDrivePowerOut;
			motor[BR] = rightDrivePowerOut;
			motor[FR] = rightDrivePowerOut;
			releaseCPU();
		}
		else
		{
		}
		wait1Msec(30);
	}
}

task AutoReleaseControl()
{
	while(true)
	{
		if(1 == vexRT[AUTORELEASE_OFF_BUTTON])
		{
			autoReleaseToggle = false;
		}
		else if(1 == vexRT[AUTORELEASE_ON_BUTTON])
		{
			autoReleaseToggle = true;
		}

		presentLiftAngle = SensorValue[POT];
		liftSpeed = (presentLiftAngle - previousLiftAngle);

		if(autoReleaseToggle == true)
		{
			if(liftSpeed < 60)
			{
				autoReleasePoint = 2000;
				oneStar = false;
				twoStars = false;
				threeStars = false;
				fourStars = true;
			}
			else if(liftSpeed < 70)
			{
				autoReleasePoint = 1900;
				oneStar = false;
				twoStars = false;
				threeStars = true;
				fourStars = false;
			}
			else if(liftSpeed < 80)
			{
				autoReleasePoint = 1850;
				oneStar = false;
				twoStars = true;
				threeStars = false;
				fourStars = false;
			}
			else
			{
				autoReleasePoint = 1700;
				oneStar = true;
				twoStars = false;
				threeStars = false;
				fourStars = false;
			}
		}
		else
		{
			autoReleasePoint = 4000;
		}

		previousLiftAngle = presentLiftAngle;

		if(SensorValue[POT] >= autoReleasePoint)
		{
			clawToggle = true;
			hogCPU();
			desiredClawAngle = 1400;
			releaseCPU();
		}

		wait1Msec(50);
	}
}

task AutonLiftControl()
{
	while(true)
	{
		if(liftToggle == true)
		{
			hogCPU();
			actualLiftAngle = SensorValue[POT];
			errorLiftAngle = (desiredLiftAngle - actualLiftAngle);
			liftPowerOut = (errorLiftAngle * 0.2);
			liftPowerOut = limitMotorPower(liftPowerOut);
			motor[LARMB] = liftPowerOut;
			motor[LARMA] = liftPowerOut;
			motor[RARMB] = liftPowerOut;
			motor[RARMA] = liftPowerOut;
			releaseCPU();
		}
		else
		{
		}
		wait1Msec(20);
	}
}

task AutonClawControl()
{
	while(true)
	{
		if(clawToggle == true)
		{
			hogCPU();
			actualClawAngle = SensorValue[POTCLAW];
			errorClawAngle = (desiredClawAngle - actualClawAngle);
			clawPowerOut = (errorClawAngle * 0.2);
			clawPowerOut = limitMotorPower(clawPowerOut);
			motor[CLAWA] = clawPowerOut;
			motor[CLAWB] = clawPowerOut;
			releaseCPU();
		}
		else
		{
		}
		wait1Msec(20);
	}
}

task LiftControl()
{
	while(true)
	{
		if(vexRT[LIFT_UP_BUTTON]== 1)
		{
			liftToggle = false;
			motor[LARMB] = 127;
			motor[RARMB] = 127;
			motor[LARMA] = 127;
			motor[RARMA] = 127;
			hogCPU();
			desiredLiftAngle = SensorValue[POT];
			releaseCPU();
		}
		else if(vexRT[LIFT_DOWN_BUTTON]== 1)
		{
			liftToggle = false;
			motor[LARMB] = -127;
			motor[RARMB] = -127;
			motor[LARMA] = -127;
			motor[RARMA] = -127;
			hogCPU();
			desiredLiftAngle = SensorValue[POT];
			releaseCPU();
		}
		/*
		else if(vexRT[HOLD_BUTTON]==1)
		{
			liftToggle = true;
			hogCPU();
			desiredLiftAngle = 1682;
			releaseCPU();
		}
		*/
		else if(vexRT[TALL_FENCE_BUTTON]==1)
		{
			liftToggle = true;
			hogCPU();
			desiredLiftAngle = 1430;
			desiredClawAngle = 1973;
			releaseCPU();
		}
		else if(vexRT[SHORT_FENCE_BUTTON]==1)
		{
			liftToggle = true;
			hogCPU();
			desiredLiftAngle = 1129;
			desiredClawAngle = 1576;
			releaseCPU();
		}
		else
		{
			liftToggle = true;
		}
		wait1Msec(20);
	}
}

task ClawControl()
{
	while(true)
	{
		if(1 == vexRT[CLAW_CLOSE_BUTTON])
		{
			clawToggle = false;
			motor[CLAWA] = 127;
			motor[CLAWB] = 127;
			hogCPU();
			desiredClawAngle = (SensorValue[POTCLAW] + 100);
			releaseCPU();
		}
		else if(1 == vexRT[CLAW_OPEN_BUTTON])
		{
			clawToggle = false;
			motor[CLAWA] = -127;
			motor[CLAWB] = -127;
			hogCPU();
			desiredClawAngle = SensorValue[POTCLAW];
			releaseCPU();
		}
		else
		{
			clawToggle = true;
		}
		wait1Msec(20);
	}
}

task DriveControl()
{
	while(true)
	{
		motor[FL] = LEFT_FORWARD_CHANNEL;
		motor[FR] = RIGHT_FORWARD_CHANNEL;
		motor[BR] = RIGHT_FORWARD_CHANNEL;
		motor[BL] = LEFT_FORWARD_CHANNEL;
	}
	wait1Msec(20);
}

task IndicatorControl()
{
	while(true)
	{
		if(oneStar == true)
		{
			SensorValue[OneIndicator] = 1;
			SensorValue[TwoIndicator] = 0;
			SensorValue[ThreeIndicator] = 0;
			SensorValue[FourIndicator] = 0;
		}
		else if(twoStars == true)
		{
			SensorValue[OneIndicator] = 1;
			SensorValue[TwoIndicator] = 1;
			SensorValue[ThreeIndicator] = 0;
			SensorValue[FourIndicator] = 0;
		}
		else if(threeStars == true)
		{
			SensorValue[OneIndicator] = 1;
			SensorValue[TwoIndicator] = 1;
			SensorValue[ThreeIndicator] = 1;
			SensorValue[FourIndicator] = 0;
		}
		else if(fourStars == true)
		{
			SensorValue[OneIndicator] = 1;
			SensorValue[TwoIndicator] = 1;
			SensorValue[ThreeIndicator] = 1;
			SensorValue[FourIndicator] = 1;
		}
		wait1Msec(20);
	}
}
