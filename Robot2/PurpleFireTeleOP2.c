#pragma config(Sensor, in1,    POT,            sensorPotentiometer)
#pragma config(Sensor, in2,    POTCLAW,        sensorPotentiometer)
#pragma config(Sensor, in5,    Gyro,           sensorGyro)
#pragma config(Sensor, dgtl9,  RightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl11, LeftEncoder,    sensorQuadEncoder)
#pragma config(Motor,  port1,           BL,            tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           FL,            tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           FR,            tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port4,           LARMA,         tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port5,           LARMB,         tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port6,           CLAWA,         tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port7,           CLAWB,         tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port8,           RARMA,         tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port9,           RARMB,         tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port10,          BR,            tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)
//Competition Control and Duration Settings
#pragma competitionControl(OFF)
//#pragma competitionControl(Competition)
#pragma autonomousDuration(60)
#pragma userControlDuration(60)
#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!


///////////
//Defines//
///////////

#define	SUPERLOOP_TICK									10
#define MAX_POWER_OUT										127
#define MIN_POWER_OUT								  	-127
#define STOP														0

#define LIFT_UP_BUTTON									Btn6U
#define LIFT_DOWN_BUTTON								Btn6D
#define CLAW_CLOSE_BUTTON								Btn5D
#define CLAW_OPEN_BUTTON								Btn5U

#define DOWN_BUTTON											Btn7D
#define HOLD_BUTTON											Btn7U
#define SCORE_BUTTON										Btn8U
#define TALL_FENCE_BUTTON								Btn8R
#define SHORT_FENCE_BUTTON							Btn8D
#define QUICK_THROW_BUTTON							Btn8L

#define AUTORELEASE_OFF_BUTTON					Btn7L
#define AUTORELEASE_ON_BUTTON						Btn7R

#define RIGHT_FORWARD_CHANNEL						vexRT[Ch2]
#define LEFT_FORWARD_CHANNEL						vexRT[Ch3]
#define RIGHT_SIDE_CHANNEL							vexRT[Ch1]
#define LEFT_SIDE_CHANNEL								vexRT[Ch4]

////////////////
//Lift Control//
////////////////

int actualLiftAngle;
int desiredLiftAngle;
int liftPowerOut;
int errorLiftAngle;
bool liftToggle;

////////////////
//Claw Control//
////////////////

int actualClawAngle;
int desiredClawAngle;
int clawPowerOut;
int errorClawAngle;
bool clawToggle;

//////////////////////////
//Autonomous Positioning//
//////////////////////////

bool straightDrive;
int driveConstant;
int presentGyroPosition;
int setGyroPosition;
int gyroError;
int rightDrivePowerOut;
int leftDrivePowerOut;

///////////////
//AutoRelease//
///////////////

int presentLiftAngle;
int previousLiftAngle;
int liftSpeed;
int autoReleasePoint;

bool fourStars;
bool threeStars;
bool twoStars;
bool oneStar;
bool autoReleaseToggle = true;





/////////////////////
//Functions Library//
/////////////////////

////////////////////////////////////////////////////////////////////////////////////////////
void SetClawAngle(int clawAngle)																													//
{																																													//
	hogCPU();																																								//
	desiredClawAngle = clawAngle;																														//
	releaseCPU();																																						//
}																																													//
////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////
void SetLiftAngle(int liftAngle)																													//
{																																													//
	hogCPU();																																								//
	desiredLiftAngle = liftAngle;																														//
	releaseCPU();																																						//
}																																													//
////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////
void DriveForward(int power, int position, int gyroSet)																		//
{																																													//
	SensorValue[RightEncoder] = 0;																													//
	SensorValue[LeftEncoder] = 0;																														//
	//
	setGyroPosition = gyroSet;																															//
	//
	straightDrive = true;																																		//
	//
	driveConstant = power;																																	//
	//
	while(SensorValue[RightEncoder] < position)																							//
	{																																												//
	}																																												//
	//
	straightDrive = false;																																	//
	//
	motor[BL] = -10;																															//
	motor[FL] = -10;																														//
	motor[BR] = -10;																														//
	motor[FR] = -10;																														//
}																																													//
////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////
void DriveBackwardsE(int power, int position, int gyroSet)																//
{																																													//
	SensorValue[RightEncoder] = 0;																													//
	SensorValue[LeftEncoder] = 0;																														//
	//
	setGyroPosition = gyroSet;																															//
	//
	straightDrive = true;																																		//
	//
	driveConstant = (-1 * power);																														//
	//
	while(SensorValue[RightEncoder] > (-1 * position))																			//
	{																																												//
	}																																												//
	//
	straightDrive = false;																																	//
	//
	motor[BL] = 10;																															//
	motor[FL] = 10;																															//
	motor[BR] = 10;																															//
	motor[FR] = 10;																														//
}																																													//
////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////
void DriveBackwardsT(int power, int waitTime)																							//
{																																													//
	SensorValue[RightEncoder] = 0;																													//
	SensorValue[LeftEncoder] = 0;																														//
	//
	//
	straightDrive = false;																																	//
	//
	motor[BL] = (-1 * power);																										//
	motor[FL] = (-1 * power);																										//
	motor[BR] = (-1 * power);																										//
	motor[FR] = (-1 * power);																									//
	//
	wait1Msec(waitTime);																																		//
	//
	straightDrive = false;																																	//
	//
	motor[BL] = 10;																															//
	motor[FL] = 10;																															//
	motor[BR] = 10;																															//
	motor[FR] = 10;																														//
}																																													//
////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////
void TurnRight(int power, int position)																										//
{																																													//
	SensorValue[RightEncoder] = 0;																													//
	SensorValue[LeftEncoder] = 0;																														//
	//
	straightDrive = false;																																	//
	//
	motor[BL] = power;																														//
	motor[FL] = power;																													//
	motor[BR] = (-1 * power);																										//
	motor[FR] = (-1 * power);																									//
	//
	while(SensorValue[Gyro] > position)																											//
	{																																												//
	}																																												//
	//
	motor[BL] = -20;																															//
	motor[FL] = -20;																														//
	motor[BR] = 20;																															//
	motor[FR] = 20;																														//
}																																													//
////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////
void TurnLeft(int power, int position)																										//
{																																													//
	SensorValue[RightEncoder] = 0;																													//
	SensorValue[LeftEncoder] = 0;																														//
	//
	straightDrive = false;																																	//
	//
	motor[BL] = (-1 * power);																										//
	motor[FL] = (-1 * power);																										//
	motor[BR] = power;																													//
	motor[FR] = power;																													//
	//
	while(SensorValue[Gyro] < position)																											//
	{																																												//
	}																																												//
	//
	motor[BL] = 20;																															//
	motor[FL] = 20;																															//
	motor[BR] = -20;																														//
	motor[FR] = -20;																														//
}																																													//
////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////
int limitMotorPower(int power)																														//
{																																													//
	int	outputPower;																																				//
	//
	outputPower = power;																																		//
	if(outputPower > MAX_POWER_OUT)																													//
	{																																												//
		outputPower = MAX_POWER_OUT;																													//
	}																																												//
	else if(outputPower < MIN_POWER_OUT)																										//
	{																																												//
		outputPower = MIN_POWER_OUT;																													//
	}																																												//
	return(outputPower);																																		//
}																																													//
////////////////////////////////////////////////////////////////////////////////////////////

void AssignDrive(int BLPower, int BRPower, int FLPower, int FRPower)
{
	motor[BL] = BLPower;
	motor[BR] = BRPower;
	motor[FL] = FLPower;
	motor[FR] = FRPower;
}

void AssignLift(int BLLPower, int BRLPower, int LLPower, int RLPower)
{
	motor[LARMB] = BLLPower;
	motor[RARMB] = BRLPower;
	motor[LARMA] = LLPower;
	motor[RARMA] = RLPower;
}




/////////
//Tasks//
/////////

task StraightDriveControl();
task AcceptDenyControl();
task AutoReleaseControl();
task AutonLiftControl();
task AutonClawControl();
task LiftControl();
task ClawControl();
task DriveControl();


/////////////////////////////////////////////////////////////////////////////////////////
//																																										 //
//                          Pre-Autonomous Functions																	 //
//																																										 //
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
}




/////////////////////////////////////////////////////////////////////////////////////////
//																																										 //
//                                 Autonomous Task																		 //
//																																										 //
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
}

/////////////////////////////////////////////////////////////////////////////////////////
//																																										 //
//                                 User Control																				 //
//																																										 //
/////////////////////////////////////////////////////////////////////////////////////////
task usercontrol()
{
	desiredClawAngle = SensorValue[POTCLAW];
	desiredLiftAngle = SensorValue[POT];
	//startTask(AcceptDenyControl);
	//startTask(AutoReleaseControl);
	startTask(AutonLiftControl);
	startTask(AutonClawControl);
	startTask(LiftControl);
	startTask(ClawControl);
	startTask(DriveControl);
	while(true)
	{
		wait1Msec(SUPERLOOP_TICK);
	}
}

task StraightDriveControl()
{
	while(true)
	{
		if(straightDrive == true)
		{
			hogCPU();
			presentGyroPosition = SensorValue[Gyro];

			gyroError = (setGyroPosition - presentGyroPosition);

			rightDrivePowerOut = ((gyroError * 0.5) + driveConstant);
			leftDrivePowerOut = ((-1 * (gyroError * 0.5)) + driveConstant);

			motor[BL] = leftDrivePowerOut;
			motor[FL] = leftDrivePowerOut;
			motor[BR] = rightDrivePowerOut;
			motor[FR] = rightDrivePowerOut;
			releaseCPU();
		}
		else
		{
		}
		wait1Msec(30);
	}
}

task AcceptDenyControl()
{
	while(true)
	{
		if(1 == vexRT[AUTORELEASE_OFF_BUTTON])
		{
			autoReleaseToggle = false;
		}
		else if(1 == vexRT[AUTORELEASE_ON_BUTTON])
		{
			autoReleaseToggle = true;
		}
		wait1Msec(20);
	}
}

task AutoReleaseControl()
{
	while(true)
	{
		presentLiftAngle = SensorValue[POT];

		liftSpeed = (presentLiftAngle - previousLiftAngle);

		if(autoReleaseToggle == true)
		{
			if(liftSpeed < 60)
			{
				autoReleasePoint = 2000;
				oneStar = false;
				twoStars = false;
				threeStars = false;
				fourStars = true;
			}
			else if(liftSpeed < 70)
			{
				autoReleasePoint = 1900;
				oneStar = false;
				twoStars = false;
				threeStars = true;
				fourStars = false;
			}
			else if(liftSpeed < 80)
			{
				autoReleasePoint = 1850;
				oneStar = false;
				twoStars = true;
				threeStars = false;
				fourStars = false;
			}
			else
			{
				autoReleasePoint = 1700;
				oneStar = true;
				twoStars = false;
				threeStars = false;
				fourStars = false;
			}
		}
		else
		{
			autoReleasePoint = 4000;
		}

		previousLiftAngle = presentLiftAngle;

		if(SensorValue[POT] >= autoReleasePoint)
		{
			clawToggle = true;
			hogCPU();
			desiredClawAngle = 1400;
			releaseCPU();
		}

		wait1Msec(50);
	}
}

task AutonLiftControl()
{
	while(true)
	{
		if(liftToggle == true)
		{
			hogCPU();
			actualLiftAngle = SensorValue[POT];
			errorLiftAngle = (desiredLiftAngle - actualLiftAngle);
			liftPowerOut = (errorLiftAngle * 0.3);
			liftPowerOut = limitMotorPower(liftPowerOut);
			motor[LARMB] = liftPowerOut;
			motor[LARMA] = liftPowerOut;
			motor[RARMB] = liftPowerOut;
			motor[RARMA] = liftPowerOut;
			releaseCPU();
		}
		else
		{
		}
		wait1Msec(20);
	}
}

task AutonClawControl()
{
	while(true)
	{
		if(clawToggle == true)
		{
			hogCPU();
			actualClawAngle = SensorValue[POTCLAW];
			errorClawAngle = (desiredClawAngle - actualClawAngle);
			clawPowerOut = (errorClawAngle * 0.3);
			clawPowerOut = limitMotorPower(clawPowerOut);
			motor[CLAWA] = clawPowerOut;
			motor[CLAWB] = clawPowerOut;
			releaseCPU();
		}
		else
		{
		}
		wait1Msec(20);
	}
}

task LiftControl()
{
	while(true)
	{
		//extra claw position set button
		//if((1 == vexRT[LIFT_UP_BUTTON]) && (1 == vexRT[LIFT_DOWN_BUTTON]))
		//{
		//	clawToggle = true;
		//	hogCPU();
		//	desiredClawAngle = 3100;
		//	releaseCPU();
		//}
		if(1 == vexRT[DOWN_BUTTON])
		{
			liftToggle = true;
			hogCPU();
			desiredLiftAngle = 120;
			releaseCPU();
		}
		else if(1 == vexRT[HOLD_BUTTON])
		{
			liftToggle = true;
			hogCPU();
			desiredLiftAngle = 1402;
			releaseCPU();
		}
		else if(1 == vexRT[SCORE_BUTTON])
		{
			liftToggle = true;
			hogCPU();
			desiredLiftAngle = 2696;
			releaseCPU();
		}
		else if(1 == vexRT[TALL_FENCE_BUTTON])
		{
			liftToggle = true;
			hogCPU();
			desiredLiftAngle = 1282;
			desiredClawAngle = 1949;
			releaseCPU();
		}
		else if(1 == vexRT[SHORT_FENCE_BUTTON])
		{
			liftToggle = true;
			hogCPU();
			desiredLiftAngle = 1112;
			desiredClawAngle = 1961;
			releaseCPU();
		}
		else if(1 == vexRT[LIFT_UP_BUTTON])
		{
			liftToggle = false;
			motor[LARMB] = 127;
			motor[RARMB] = 127;
			motor[LARMA] = 127;
			motor[RARMA] = 127;
			hogCPU();
			desiredLiftAngle = SensorValue[POT];
			releaseCPU();
		}
		else if(1 == vexRT[LIFT_DOWN_BUTTON])
		{
				liftToggle = false;
				motor[LARMB] = -127;
				motor[RARMB] = -127;
				motor[LARMA] = -127;
				motor[RARMA] = -127;
				hogCPU();
				desiredLiftAngle = SensorValue[POT];
				releaseCPU();
		}
		else
		{
			liftToggle = true;
		}
		wait1Msec(20);
	}
}

task ClawControl()
{
	while(true)
	{
		//if((1 == vexRT[CLAW_OPEN_BUTTON]) && (1 == vexRT[CLAW_CLOSE_BUTTON]))
		//{
		//	clawToggle = false;
		//	motor[CLAWA] = 127;
		//	motor[CLAWB] = 127;
		//	wait1Msec(1000);
		//	hogCPU();
		//	desiredClawAngle = (SensorValue[POTCLAW] + 100);
		//	releaseCPU();
		//}
		if(1 == vexRT[CLAW_CLOSE_BUTTON])
		{
			clawToggle = false;
			motor[CLAWA] = 127;
			motor[CLAWB] = 127;
			hogCPU();
			desiredClawAngle = (SensorValue[POTCLAW] + 100);
			releaseCPU();
		}
		else if(1 == vexRT[CLAW_OPEN_BUTTON])
		{
			clawToggle = false;
			motor[CLAWA] = -127;
			motor[CLAWB] = -127;
			hogCPU();
			desiredClawAngle = SensorValue[POTCLAW];
			releaseCPU();
		}
		else
		{
			clawToggle = true;
		}
		wait1Msec(20);
	}
}

task DriveControl()
{
	while(true)
	{
		motor[FL] = LEFT_FORWARD_CHANNEL;
		motor[FR] = RIGHT_FORWARD_CHANNEL;
		motor[BR] = RIGHT_FORWARD_CHANNEL;
		motor[BL] = LEFT_FORWARD_CHANNEL;
	}
	wait1Msec(20);
}
