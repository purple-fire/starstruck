#pragma config(Sensor, in1,    POT,            sensorPotentiometer)
#pragma config(Sensor, in2,    POTCLAW,        sensorPotentiometer)
#pragma config(Sensor, in4,    Gyro,           sensorGyro)
#pragma config(Sensor, dgtl9,  RightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl11, LeftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  OneIndicator,   sensorLEDtoVCC)
#pragma config(Sensor, dgtl6,  TwoIndicator,   sensorLEDtoVCC)
#pragma config(Sensor, dgtl7,  ThreeIndicator, sensorLEDtoVCC)
#pragma config(Sensor, dgtl8,  FourIndicator,  sensorLEDtoVCC)
#pragma config(Motor,  port1,           BL,            tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           FL,            tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           FR,            tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port4,           LARMA,         tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port5,           LARMB,         tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port6,           CLAWA,         tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port7,           CLAWB,         tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port8,           RARMA,         tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port9,           RARMB,         tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port10,          BR,            tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)
//Competition Control and Duration Settings
#pragma competitionControl(OFF)
//#pragma competitionControl(Competition)
#pragma autonomousDuration(60)
#pragma userControlDuration(60)
#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!


///////////
//Defines//
///////////

#define	SUPERLOOP_TICK									10
#define MAX_POWER_OUT										127
#define MIN_POWER_OUT								  	-127
#define STOP														0

#define LIFT_UP_BUTTON									Btn6U
#define LIFT_DOWN_BUTTON								Btn6D
#define CLAW_CLOSE_BUTTON								Btn5D
#define CLAW_OPEN_BUTTON								Btn5U

#define DOWN_BUTTON											Btn7D
#define HOLD_BUTTON											Btn7U
#define SCORE_BUTTON										Btn8U
#define TALL_FENCE_BUTTON								Btn8R
#define SHORT_FENCE_BUTTON							Btn8D
#define QUICK_THROW_BUTTON							Btn8L

#define AUTORELEASE_OFF_BUTTON					Btn7L
#define AUTORELEASE_ON_BUTTON						Btn7R

#define RIGHT_FORWARD_CHANNEL						vexRT[Ch2]
#define LEFT_FORWARD_CHANNEL						vexRT[Ch3]
#define RIGHT_SIDE_CHANNEL							vexRT[Ch1]
#define LEFT_SIDE_CHANNEL								vexRT[Ch4]

////////////////
//Positions   //
////////////////

#define clawOpen 1345
#define clawClose 442
#define armDown 68
#define armUp 1311
#define armChuck 2840

////////////////
//Lift Control//
////////////////

int actualLiftAngle;
int desiredLiftAngle;
int liftPowerOut;
int errorLiftAngle;
bool liftToggle;

////////////////
//Claw Control//
////////////////

int actualClawAngle;
int desiredClawAngle;
int clawPowerOut;
int errorClawAngle;
bool clawToggle;

//////////////////////////
//Autonomous Positioning//
//////////////////////////

bool straightDrive;
int driveConstant;
int presentGyroPosition;
int setGyroPosition;
int gyroError;
int rightDrivePowerOut;
int leftDrivePowerOut;

///////////////
//AutoRelease//
///////////////

int presentLiftAngle;
int previousLiftAngle;
int liftSpeed;
int autoReleasePoint;

bool fourStars;
bool threeStars;
bool twoStars;
bool oneStar;
bool autoReleaseToggle = true;


/////////////////////
//Functions Library//
/////////////////////

////////////////////////////////////////////////////////////////////////////////////////////
void SetClawAngle(int clawAngle)																													//
{																																													//
	hogCPU();																																								//
	desiredClawAngle = clawAngle;																														//
	releaseCPU();																																						//
}																																													//
////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////
void SetLiftAngle(int liftAngle)																													//
{																																													//
	hogCPU();																																								//
	desiredLiftAngle = liftAngle;																														//
	releaseCPU();																																						//
}																																													//
////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////
void DriveForward(int power, int position, int gyroSet)																		//
{																																													//
	SensorValue[RightEncoder] = 0;																													//
	SensorValue[LeftEncoder] = 0;																														//
	//
	setGyroPosition = gyroSet;																															//
	//
	straightDrive = true;																																		//
	//
	driveConstant = power;																																	//
	//
	while(SensorValue[RightEncoder] < position)																							//
	{																																												//
	}																																												//
	//
	straightDrive = false;																																	//
	//
	motor[BL] = -10;																																			   	//
	motor[FL] = -10;																																					//
	motor[BR] = -10;																																					//
	motor[FR] = -10;																																					//
}																																													//
////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////
void DriveBackwardsE(int power, int position, int gyroSet)																//
{																																													//
	SensorValue[RightEncoder] = 0;																													//
	SensorValue[LeftEncoder] = 0;																														//
	//
	setGyroPosition = gyroSet;																															//
	//
	straightDrive = true;																																		//
	//
	driveConstant = (-1 * power);																														//
	//
	while(SensorValue[RightEncoder] > (-1 * position))																			//
	{																																												//
	}																																												//
	//
	straightDrive = false;																																	//
	//
	motor[BL] = 10;																																					//
	motor[FL] = 10;																																					//
	motor[BR] = 10;																																					//
	motor[FR] = 10;																																					//
}																																													//
////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////
void DriveBackwardsT(int power, int waitTime)																							//
{																																													//
	SensorValue[RightEncoder] = 0;																													//
	SensorValue[LeftEncoder] = 0;																														//
	//
	//
	straightDrive = false;																																	//
	//
	motor[BL] = (-1 * power);																																//
	motor[FL] = (-1 * power);																																//
	motor[BR] = (-1 * power);																																//
	motor[FR] = (-1 * power);																																//
	//
	wait1Msec(waitTime);																																		//
	//
	straightDrive = false;																																	//
	//
	motor[BL] = 10;																																					//
	motor[FL] = 10;																																					//
	motor[BR] = 10;																																					//
	motor[FR] = 10;																																					//
}																																													//
////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////
void TurnRight(int power, int position)
{
	SensorValue[RightEncoder] = 0;
	SensorValue[LeftEncoder] = 0;
	straightDrive = false;
	motor[BL] = power;
	motor[FL] = power;
	motor[BR] = (-1 * power);
	motor[FR] = (-1 * power);
	while(SensorValue[Gyro] < position)
	{
	}
	motor[BL] = -10;
	motor[FL] = -10;
	motor[BR] = 10;
	motor[FR] = 10;
}
////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////
void TurnLeft(int power, int position)
{
	SensorValue[RightEncoder] = 0;
	SensorValue[LeftEncoder] = 0;
	straightDrive = false;
	motor[BL] = (-1 * power);
	motor[FL] = (-1 * power);
	motor[BR] = power;
	motor[FR] = power;
	while(SensorValue[Gyro] > position)
	{
	}
	motor[BL] = 10;
	motor[FL] = 10;
	motor[BR] = -10;
	motor[FR] = -10;
}
////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////
int limitMotorPower(int power)																														//
{																																													//
	int	outputPower;																																				//
	//
	outputPower = power;																																		//
	if(outputPower > MAX_POWER_OUT)																													//
	{																																												//
		outputPower = MAX_POWER_OUT;																													//
	}																																												//
	else if(outputPower < MIN_POWER_OUT)																										//
	{																																												//
		outputPower = MIN_POWER_OUT;																													//
	}																																												//
	return(outputPower);																																		//
}																																													//
////////////////////////////////////////////////////////////////////////////////////////////

void AssignDrive(int BLPower, int BRPower, int FLPower, int FRPower)
{
	motor[BL] = BLPower;
	motor[BR] = BRPower;
	motor[FL] = FLPower;
	motor[FR] = FRPower;
}

void AssignLift(int BLLPower, int BRLPower, int LLPower, int RLPower)
{
	motor[LARMB] = BLLPower;
	motor[RARMB] = BRLPower;
	motor[LARMA] = LLPower;
	motor[RARMA] = RLPower;
}

void stopBot(){
	motor[BL] = 0;																																			   	//
	motor[FL] = 0;																																					//
	motor[BR] = 0;																																					//
	motor[FR] = 0;																																					//
}
/////////
//Tasks//
/////////

task StraightDriveControl();
task AutoReleaseControl();
task AutonLiftControl();
task AutonClawControl();
task LiftControl();
task ClawControl();
task DriveControl();
task IndicatorControl();

/////////////////////////////////////////////////////////////////////////////////////////
//																																										 //
//                          Pre-Autonomous Functions																	 //
//																																										 //
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
}




/////////////////////////////////////////////////////////////////////////////////////////
//																																										 //
//                                 Autonomous Task																		 //
//																																										 //
/////////////////////////////////////////////////////////////////////////////////////////

/////////////////////
//Autonomous Skills//
/////////////////////

//task usercontrol()
task autonomous
{
	//start tasks
	startTask(StraightDriveControl);
	startTask(AutoReleaseControl);
	startTask(IndicatorControl);
	startTask(AutonClawControl);
	startTask(AutonLiftControl);

	desiredClawAngle = SensorValue[POTCLAW];
	desiredLiftAngle = SensorValue[POT];

	//enable toggles
	liftToggle = true;
	clawToggle = true;
	autoReleaseToggle = true;

	//reset gyro
	SensorValue[Gyro] = 0;

	//open claw and midfield drive
	SetClawAngle(clawOpen);
	DriveForward(100, 500, 0);

	//turn towards cube
	TurnLeft(100, -600);

	wait1Msec(200);

	//drive into cube
	DriveForward(100, 500,-600);

	//start claw close
	clawToggle = false;
	motor[CLAWA] = -127;
	motor[CLAWB] = -127;

	//finish cube drive
	DriveForward(100, 180,-600);
	SetLiftAngle(1600);

	//wait for lift to move and enable claw control
	while(SensorValue[POT] < 1000)
	{
	}
	motor[CLAWA] = 0;
	motor[CLAWB] = 0;
	clawToggle = true;
	SetClawAngle(SensorValue[POTCLAW] - 100);

	//back up to prep for throw
	DriveBackwardsE(100, 600, -900);

	wait1Msec(500);

	//turn to throw
	TurnLeft(70, -1500);

	//back up to throw field cube
	DriveBackwardsE(100, 100, -1710);
	//throw cube
	SetLiftAngle(2650);
	//finish back drive
	DriveBackwardsT(127, 500);

	//drop lift
	SetLiftAngle(armDown);
	//wait for lift to lower
	while(SensorValue[POT] > 800)
	{
	}

	//drive into first load
	DriveForward(100, 825, -1498);

	//grab first load
	clawToggle = false;
	motor[CLAWA] = -127;
	motor[CLAWB] = -127;
	wait1Msec(1100);
	SetLiftAngle(1600);
	//wait for lift to move and enable claw control
	while(SensorValue[POT] < 1000)
	{
	}
	motor[CLAWA] = 0;
	motor[CLAWB] = 0;
	clawToggle = true;
	SetClawAngle(SensorValue[POTCLAW] - 100);

	//lift first load and back up
	SetLiftAngle(1750);
	DriveBackwardsE(100, 300, -1478);
	//wait for lift
	while(SensorValue[POT] < 1700)
	{
	}

	//back up to throw
	DriveBackwardsE(100, 170, -1478);
	//throw
	SetLiftAngle(2650);
	DriveBackwardsT(100, 300);

	//drop lift
	SetLiftAngle(armDown);
	//wait for lift to lower
	while(SensorValue[POT] > 800)
	{
	}

	//drive into second load
	DriveForward(100, 825, -1498);

	clawToggle = false;
	motor[CLAWA] = -127;
	motor[CLAWB] = -127;
	wait1Msec(1100);
	SetLiftAngle(1600);
	//wait for lift to move and enable claw control
	while(SensorValue[POT] < 1000)
	{
	}
	motor[CLAWA] = 0;
	motor[CLAWB] = 0;
	clawToggle = true;
	SetClawAngle(SensorValue[POTCLAW] - 100);

	//lift first load and back up
	SetLiftAngle(1750);
	DriveBackwardsE(100, 300, -1145);
	//wait for lift
	while(SensorValue[POT] < 1700)
	{
	}

	//back up to throw
	DriveBackwardsE(110, 150, -1145);
	//throw
	SetLiftAngle(2650);
	DriveBackwardsT(110, 320);

	//drop lift
	SetLiftAngle(armDown);
	//wait for lift to lower
	while(SensorValue[POT] > 800)
	{
	}
	SetClawAngle(clawClose);

	stopBot();
	/*

	//drive into stars
	DriveForward(100, 350, -870);

	//allign to stars
	TurnRight(100, -1100);

	//turn back to front stars
	TurnLeft(100, -860);

	//drive into stars
	DriveForward(100, 650, -945);

	//grab stars
	clawToggle = false;
	motor[CLAWA] = 127;
	motor[CLAWB] = 127;
	wait1Msec(500);

	//lift front stars
	SetLiftAngle(200);
	wait1Msec(300);

	//spin to throw stars
	TurnRight(100, -1750);

	//enable claw control
	clawToggle = true;
	SetClawAngle(SensorValue[POTCLAW] + 200);

	//throw stars
	SetLiftAngle(2650);
	DriveForward(100, 200, -1940);
	while(SensorValue[POT] < 1700)
	{
	}
	//back up
	DriveBackwardsT(100, 750);

	//drop lift
	SetLiftAngle(0);
	//wait for lift
	while(SensorValue[POT] > 800)
	{
	}

	//drive into back stars
	SetClawAngle(1500);
	DriveForward(100, 1100 , -1970);

	//grab back stars
	SetClawAngle(3100);
	wait1Msec(800);

	//back up
	DriveBackwardsE(100, 220, -1950);

	//open claw
	SetClawAngle(2500);

	//drive into back stars again
	DriveForward(100, 80, -1910);

	//set claw angle
	SetClawAngle(3200);

	//finish back drive
	DriveForward(100, 70, -1910);
	wait1Msec(200);

	//lift stars and back up
	SetLiftAngle(2650); //1650
	DriveBackwardsE(100, 600, -1980);

	//wait for lift
	//while(SensorValue[POT] < 1500)
	//{
	//}

	//throw back stars
	SetLiftAngle(2650);
	DriveBackwardsT(100, 1000);
	wait1Msec(500);

	//lower lift
	SetLiftAngle(0);
	//wait for lift
	while(SensorValue[POT] > 1000)
	{
	}

	//drive away from fence
	DriveForward(100, 200, -1910);
	wait1Msec(200);

	//turn towards cube
	TurnLeft(70, -1430);

	//drive into cube
	DriveForward(100, 1050, -1400);

	//grab cube
	clawToggle = false;
	motor[CLAWA] = 127;
	motor[CLAWB] = 127;
	wait1Msec(800);

	//lift cube and back up
	SetLiftAngle(1650);

	//enable claw control
	clawToggle = true;
	SetClawAngle(SensorValue[POTCLAW] + 300);

	wait1Msec(300);

	//turn to dump cube
	TurnRight(100, -2000);
	wait1Msec(500);

	//drive backwards to dump last cube
	DriveBackwardsE(100, 770, -2100);   //650 position

	//throw cube
	SetLiftAngle(2650);
	DriveBackwardsT(100, 1000);
	wait1Msec(300);

	//drop lift and set claw
	SetLiftAngle(1000);
	SetClawAngle(2300);

	//wait for lift to lower
	while(SensorValue[POT] > 1100)
	{
	}


	//drive away from fence
	DriveForward(100, 1050, -1935);

	//bump wall
	AssignDrive(127, 127, 127, 127);
	wait1Msec(1000);

	//reset gyro
	SensorValue[Gyro] = 0;
	//set claw
	SetClawAngle(2300);

	//back up
	DriveBackwardsE(100, 30, 0);

	//turn towards last star
	TurnLeft(70, 880);

	//drop lift
	SetLiftAngle(0);
	wait1Msec(800);

	//drive into star
	AssignDrive(100, 100, 100, 100);
	wait1Msec(500);

	//grab star
	SetClawAngle(3100);
	wait1Msec(300);

	//lift star and back up
	DriveBackwardsE(100, 180, 900);
	wait1Msec(200);
	SetLiftAngle(1400);
	//wait for lift
	while(SensorValue[POT] < 1200)
	{
	}

	//drive forward
	DriveForward(60, 220, 900);
	wait1Msec(200);

	//spin to line up for hang
	TurnLeft(60, 2380);

	//drop star and lift
	SetClawAngle(1400);
	SetLiftAngle(900);
	wait1Msec(500);

	//back into hanging pole
	DriveBackwardsE(60, 60, 2420);
	straightDrive = true;
	setGyroPosition = 2420;
	AssignDrive(-127, -127, -127, -127);
	wait1Msec(300);

	//lift into pole
	SetLiftAngle(3000);
	AssignDrive(-80, -80, -80, -80);
	wait1Msec(1100);
	straightDrive = false;
	AssignDrive(-127, -127, -127, -127);
	wait1Msec(400);






	//drive forward
	AssignDrive(127, 127, 127, 127);
	wait1Msec(500);

	//disable toggles
	autoReleaseToggle = false;
	liftToggle = false;
	//clawToggle = false;

	//hang
	AssignLift(-127, -127, -127, -127);
	wait1Msec(800);

	//disable drive
	AssignDrive(0, 0, 0, 0);

	//wait for lift
	while(SensorValue[POT] > 400)
	{
	}

	clawToggle = false;

	//close claw
	motor[CLAWA] = -127;
	motor[CLAWB] = -127;

	wait1Msec(1500);

	AssignLift(20, 20, 20, 20);

	*/

	while(true)
	{
		wait1Msec(20);
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
//																																										 //
//                                 User Control																				 //
//																																										 //
/////////////////////////////////////////////////////////////////////////////////////////
task usercontrol()
//task autonomous()
{
	desiredClawAngle = SensorValue[POTCLAW];
	desiredLiftAngle = SensorValue[POT];
	startTask(AutoReleaseControl);
	startTask(IndicatorControl);
	startTask(AutonLiftControl);
	startTask(AutonClawControl);
	startTask(LiftControl);
	startTask(ClawControl);
	startTask(DriveControl);
	while(true)
	{
		wait1Msec(SUPERLOOP_TICK);
	}
}

task StraightDriveControl()
{
	while(true)
	{
		if(straightDrive == true)
		{
			hogCPU();
			presentGyroPosition = SensorValue[Gyro];

			gyroError = (setGyroPosition - presentGyroPosition);

			rightDrivePowerOut = ((-gyroError * 0.5) + driveConstant);
			leftDrivePowerOut = ((-1 * (-gyroError * 0.5)) + driveConstant);

			motor[BL] = leftDrivePowerOut;
			motor[FL] = leftDrivePowerOut;
			motor[BR] = rightDrivePowerOut;
			motor[FR] = rightDrivePowerOut;
			releaseCPU();
		}
		else
		{
		}
		wait1Msec(30);
	}
}

task AutoReleaseControl()
{
	while(true)
	{
		if(1 == vexRT[AUTORELEASE_OFF_BUTTON])
		{
			autoReleaseToggle = false;
		}
		else if(1 == vexRT[AUTORELEASE_ON_BUTTON])
		{
			autoReleaseToggle = true;
		}

		presentLiftAngle = SensorValue[POT];
		liftSpeed = (presentLiftAngle - previousLiftAngle);

		if(autoReleaseToggle == true)
		{
			if(liftSpeed < 60)
			{
				autoReleasePoint = 2000;
				oneStar = false;
				twoStars = false;
				threeStars = false;
				fourStars = true;
			}
			else if(liftSpeed < 70)
			{
				autoReleasePoint = 1900;
				oneStar = false;
				twoStars = false;
				threeStars = true;
				fourStars = false;
			}
			else if(liftSpeed < 80)
			{
				autoReleasePoint = 1850;
				oneStar = false;
				twoStars = true;
				threeStars = false;
				fourStars = false;
			}
			else
			{
				autoReleasePoint = 1700;
				oneStar = true;
				twoStars = false;
				threeStars = false;
				fourStars = false;
			}
		}
		else
		{
			autoReleasePoint = 4000;
		}

		previousLiftAngle = presentLiftAngle;

		if(SensorValue[POT] >= autoReleasePoint)
		{
			clawToggle = true;
			hogCPU();
			desiredClawAngle = 1400;
			releaseCPU();
		}

		wait1Msec(50);
	}
}

task AutonLiftControl()
{
	while(true)
	{
		if(liftToggle == true)
		{
			hogCPU();
			actualLiftAngle = SensorValue[POT];
			errorLiftAngle = (desiredLiftAngle - actualLiftAngle);
			liftPowerOut = (errorLiftAngle * 0.2);
			liftPowerOut = limitMotorPower(liftPowerOut);
			motor[LARMB] = liftPowerOut;
			motor[LARMA] = liftPowerOut;
			motor[RARMB] = liftPowerOut;
			motor[RARMA] = liftPowerOut;
			releaseCPU();
		}
		else
		{
		}
		wait1Msec(20);
	}
}

task AutonClawControl()
{
	while(true)
	{
		if(clawToggle == true)
		{
			hogCPU();
			actualClawAngle = SensorValue[POTCLAW];
			errorClawAngle = (desiredClawAngle - actualClawAngle);
			clawPowerOut = (errorClawAngle * 0.2);
			clawPowerOut = limitMotorPower(clawPowerOut);
			motor[CLAWA] = clawPowerOut;
			motor[CLAWB] = clawPowerOut;
			releaseCPU();
		}
		else
		{
		}
		wait1Msec(20);
	}
}

task LiftControl()
{
	while(true)
	{
		if(1 == vexRT[DOWN_BUTTON])
		{
			liftToggle = true;
			hogCPU();
			desiredLiftAngle = 120;
			releaseCPU();
		}
		else if(1 == vexRT[HOLD_BUTTON])
		{
			liftToggle = true;
			hogCPU();
			desiredLiftAngle = 1682;
			releaseCPU();
		}
		else if(1 == vexRT[SCORE_BUTTON])
		{
			liftToggle = true;
			hogCPU();
			desiredLiftAngle = 2734;
			releaseCPU();
		}
		else if(1 == vexRT[TALL_FENCE_BUTTON])
		{
			liftToggle = true;
			hogCPU();
			desiredLiftAngle = 1297;
			desiredClawAngle = 1970;
			releaseCPU();
		}
		else if(1 == vexRT[SHORT_FENCE_BUTTON])
		{
			liftToggle = true;
			hogCPU();
			desiredLiftAngle = 955;
			desiredClawAngle = 246;
			releaseCPU();
		}
		else if(1 == vexRT[LIFT_UP_BUTTON])
		{
			liftToggle = false;
			motor[LARMB] = 127;
			motor[RARMB] = 127;
			motor[LARMA] = 127;
			motor[RARMA] = 127;
			hogCPU();
			desiredLiftAngle = SensorValue[POT];
			releaseCPU();
		}
		else if(1 == vexRT[LIFT_DOWN_BUTTON])
		{
			liftToggle = false;
			motor[LARMB] = -127;
			motor[RARMB] = -127;
			motor[LARMA] = -127;
			motor[RARMA] = -127;
			hogCPU();
			desiredLiftAngle = SensorValue[POT];
			releaseCPU();
		}
		else
		{
			liftToggle = true;
		}
		wait1Msec(20);
	}
}

task ClawControl()
{
	while(true)
	{
		if(1 == vexRT[CLAW_CLOSE_BUTTON])
		{
			clawToggle = false;
			motor[CLAWA] = 127;
			motor[CLAWB] = 127;
			hogCPU();
			desiredClawAngle = (SensorValue[POTCLAW] + 100);
			releaseCPU();
		}
		else if(1 == vexRT[CLAW_OPEN_BUTTON])
		{
			clawToggle = false;
			motor[CLAWA] = -127;
			motor[CLAWB] = -127;
			hogCPU();
			desiredClawAngle = SensorValue[POTCLAW];
			releaseCPU();
		}
		else
		{
			clawToggle = true;
		}
		wait1Msec(20);
	}
}

task DriveControl()
{
	while(true)
	{
		motor[FL] = LEFT_FORWARD_CHANNEL;
		motor[FR] = RIGHT_FORWARD_CHANNEL;
		motor[BR] = RIGHT_FORWARD_CHANNEL;
		motor[BL] = LEFT_FORWARD_CHANNEL;
	}
	wait1Msec(20);
}

task IndicatorControl()
{
	while(true)
	{
		if(oneStar == true)
		{
			SensorValue[OneIndicator] = 1;
			SensorValue[TwoIndicator] = 0;
			SensorValue[ThreeIndicator] = 0;
			SensorValue[FourIndicator] = 0;
		}
		else if(twoStars == true)
		{
			SensorValue[OneIndicator] = 1;
			SensorValue[TwoIndicator] = 1;
			SensorValue[ThreeIndicator] = 0;
			SensorValue[FourIndicator] = 0;
		}
		else if(threeStars == true)
		{
			SensorValue[OneIndicator] = 1;
			SensorValue[TwoIndicator] = 1;
			SensorValue[ThreeIndicator] = 1;
			SensorValue[FourIndicator] = 0;
		}
		else if(fourStars == true)
		{
			SensorValue[OneIndicator] = 1;
			SensorValue[TwoIndicator] = 1;
			SensorValue[ThreeIndicator] = 1;
			SensorValue[FourIndicator] = 1;
		}
		wait1Msec(20);
	}
}
