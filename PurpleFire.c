#pragma config(Sensor, in1,    POT,            sensorPotentiometer)
#pragma config(Sensor, in2,    POTCLAW,        sensorPotentiometer)
#pragma config(Motor,  port1,           BL,            tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           RARMA,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           RARMB,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           LARMA,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           LARMB,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           FR,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           FL,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           CLAW1,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           CLAW2,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          BR,            tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

// Controller 1/2, Stick L/R, Axis X/Y
#define C1LX vexRT[Ch4]
#define C1LY vexRT[Ch3]
#define C1RX vexRT[Ch1]
#define ARMUP vexRT[Btn6U]
#define ARMDOWN vexRT[ChBtn6D]

#define downPOS 4095
#define upPOS 3483
#define chuckPOS 2355
#define pushPOS 3150

#define clawOPEN 1548
#define clawCLOSE 270

int autoPilotActive = 0;
int armMode = 0;
int clawMode = 0;
float target;
float clawTarget;

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/
//Task to Manage Arm Position
task claw()
{
	clawTarget = clawCLOSE;
	float proportionalCoefficient = 0.5;
	float error,
	motorPower,
	proportional; //what you set the motors to
	while (true)
	{
		//ENABLE PID
		if(clawMode==1){
			error = clawTarget - SensorValue[POTCLAW];
			proportional = error * proportionalCoefficient;
			motorPower = proportional;
			motor[CLAW1] = -motorPower;
			motor[CLAW2] = -motorPower;
		}
		//DISABLE PID
		else if(clawMode==0){
			//Claw Open
			if(vexRT[Btn8U] == 1)
			{
				motor[CLAW1] = 75;
				motor[CLAW2] = 75;
			}
			//Claw Close
			else if(vexRT[Btn8D] == 1)
			{
				motor[CLAW1] = -75;
				motor[CLAW2] = -75;
			}
			//Arm Stop
			else{
				clawTarget = SensorValue[POTCLAW];
				clawMode = 1;
			}
			// Motor values can only be updated every 20ms
			wait1Msec(20);
		}
	}
}

//Task to Manage Arm Position
task runArm()
{
	target = downPOS;
	float proportionalCoefficient = 0.5;
	float error,
	motorPower,
	proportional; //what you set the motors to
	while (true)
	{
		//ENABLE PID
		if(armMode==1){
			error = target - SensorValue[POT];
			proportional = error * proportionalCoefficient;
			motorPower = proportional;
			motor[RARMA] = motorPower;
			motor[RARMB] = motorPower;
			motor[LARMA] = motorPower;
			motor[LARMB] = motorPower;
		}
		//DISABLE PID
		else if(armMode==0){
			//Arm UP
			if(vexRT[Btn5U] == 1)
			{
				//Soft Limit For Going UP
				if(SensorValue[POT]>chuckPOS){
					motor[RARMA] = -127;
					motor[RARMB] = -127;
					motor[LARMA] = -127;
					motor[LARMB] = -127;
				}
				else{
					motor[RARMA] = 0;
					motor[RARMB] = 0;
					motor[LARMA] = 0;
					motor[LARMB] = 0;
				}
			}
			//Arm Down
			else if(vexRT[Btn5D] == 1)
			{
				//Soft Limit For Going DOWN
				if(SensorValue[POT]<downPOS){
					motor[RARMA] = 50;
					motor[RARMB] = 50;
					motor[LARMA] = 50;
					motor[LARMB] = 50;
				}
				else{
					motor[RARMA] = 0;
					motor[RARMB] = 0;
					motor[LARMA] = 0;
					motor[LARMB] = 0;
				}
			}
			//Arm Stop
			else{
				motor[RARMA] = 0;
				motor[RARMB] = 0;
				motor[LARMA] = 0;
				motor[LARMB] = 0;
			}
			// Motor values can only be updated every 20ms
			wait1Msec(20);
		}
	}
}

//Holonomic Drive using 3 Inputs
void holonomicDrive(int Y1,int X1,int X2)
{
	// Y component, X component, Rotation
	motor[FL] = -Y1 - X1 - X2;
	motor[FR] =  Y1 - X1 - X2;
	motor[BR] =  Y1 + X1 - X2;
	motor[BL] = -Y1 + X1 - X2;
}

//Holonomic Drive using 3 Inputs
void holonomicDrive(int Y1,int X1,int X2, float seconds)
{
	// Y component, X component, Rotation
	motor[FL] = -Y1 - X1 - X2;
	motor[FR] =  Y1 - X1 - X2;
	motor[BR] =  Y1 + X1 - X2;
	motor[BL] = -Y1 + X1 - X2;
	wait1Msec(seconds*1000);
}

//Holonomic Drive Forward using speed Input
void holonomicForward(int speed, float seconds)
{
	// Y component, X component, Rotation
	motor[FL] = -speed;
	motor[FR] =  speed;
	motor[BR] =  speed;
	motor[BL] = -speed;
	wait1Msec(seconds*1000);
}

//Holonomic Drive Backward using speed Input
void holonomicBackward(int speed, float seconds)
{
	// Y component, X component, Rotation
	motor[FL] =  speed;
	motor[FR] = -speed;
	motor[BR] = -speed;
	motor[BL] =  speed;
	wait1Msec(seconds*1000);
}

//Holonomic Drive Left using speed Input
void holonomicRight(int speed, float seconds)
{
	// Y component, X component, Rotation
	motor[FL] = -speed;
	motor[FR] = -speed;
	motor[BR] = speed;
	motor[BL] = speed;
	wait1Msec(seconds*1000);
}

//Holonomic Drive Right using speed Input
void holonomicLeft(int speed, float seconds)
{
	// Y component, X component, Rotation
	motor[FL] = speed;
	motor[FR] = speed;
	motor[BR] = -speed;
	motor[BL] = -speed;
	wait1Msec(seconds*1000);
}

//Holonomic Drive Rotate Left using speed Input
void holonomicRotateLeft(int speed,float seconds)
{
	// Y component, X component, Rotation
	motor[FL] = speed;
	motor[FR] = speed;
	motor[BR] = speed;
	motor[BL] = speed;
	wait1Msec(seconds*1000);
}

//Holonomic Drive Rotate Right using speed Input
void holonomicRotateRight(int speed, float seconds)
{
	// Y component, X component, Rotation
	motor[FL] = -speed;
	motor[FR] = -speed;
	motor[BR] = -speed;
	motor[BL] = -speed;
	wait1Msec(seconds*1000);
}

//Stop All Motors
void holonomicStop()
{
	motor[FL] = 0;
	motor[FR] = 0;
	motor[BR] = 0;
	motor[BL] = 0;
}

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	bStopTasksBetweenModes = false;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

	// All activities that occur before the competition starts
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task autonomous()
{
	armMode = 1;
	clawMode = 1;
	//Start Arm/Claw Management Task
	startTask(runArm);
	startTask(claw);

	//Push Off Right Stars
	target = downPOS;
	clawTarget = clawCLOSE+75;
	wait1Msec(800);
	target = pushPOS;
	clawTarget = clawOPEN;
	wait1Msec(1000);
	holonomicForward(110,1);
	holonomicRight(40,.7);
	holonomicRotateLeft(25,.25);
	holonomicForward(115,.55);
	target = pushPOS-400;

	//Go Get Stars
	wait1Msec(500);
	holonomicBackward(110,2);
	holonomicStop();
	wait1Msec(1500);
	clawTarget = clawCLOSE;
	wait1Msec(500);
	holonomicForward(110,1.45);
	clawTarget = clawOPEN;

	//Go Get Cube 1
	wait1Msec(1000);
	holonomicBackward(110,2);
	holonomicStop();
	wait1Msec(1000);
	clawTarget = clawCLOSE;
	wait1Msec(500);
	holonomicForward(110,1.45);
	clawTarget = clawOPEN;

	//Go Get Cube 2
	wait1Msec(500);
	holonomicBackward(110,2);
	holonomicStop();
	wait1Msec(1000);
	clawTarget = clawCLOSE;
	wait1Msec(500);
	holonomicForward(110,1.45);
	clawTarget = clawOPEN;

	//Push second fence jacks
	holonomicBackward(110, 0.5);
	holonomicStop();
	wait1Msec(1000);
	holonomicRotateLeft(25,0.5);
	holonomicLeft(110,1.5);
	holonomicRotateRight(25,0.25);

	//Stop Holonomic
	holonomicStop();

	//DONE!
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/
task autoPilot()
{
	armMode = 1;
	clawMode = 1;
	//Start Arm/Claw Management Task
	startTask(runArm);
	startTask(claw);

	//Push Off Right Stars
	target = downPOS;
	clawTarget = clawCLOSE+75;
	wait1Msec(800);
	target = pushPOS;
	clawTarget = clawOPEN;
	wait1Msec(1000);
	holonomicForward(110,1);
	holonomicRight(40,.7);
	holonomicRotateLeft(25,.25);
	holonomicForward(115,.55);
	target = pushPOS-400;

	//Go Get Stars
	wait1Msec(500);
	holonomicBackward(110,2);
	holonomicStop();
	wait1Msec(1500);
	clawTarget = clawCLOSE;
	wait1Msec(500);
	holonomicForward(110,1.45);
	clawTarget = clawOPEN;

	//Go Get Cube 1
	wait1Msec(1000);
	holonomicBackward(110,2);
	holonomicStop();
	wait1Msec(1000);
	clawTarget = clawCLOSE;
	wait1Msec(500);
	holonomicForward(110,1.45);
	clawTarget = clawOPEN;

	//Go Get Cube 2
	wait1Msec(500);
	holonomicBackward(110,2);
	holonomicStop();
	wait1Msec(1000);
	clawTarget = clawCLOSE;
	wait1Msec(500);
	holonomicForward(110,1.45);
	clawTarget = clawOPEN;

	//Push second fence jacks
	holonomicBackward(110, 0.5);
	holonomicStop();
	wait1Msec(1000);
	holonomicRotateLeft(25,0.5);
	holonomicLeft(110,1.5);
	holonomicRotateRight(25,0.25);

	//Stop Holonomic
	holonomicStop();

	//DONE!
}

task usercontrol()
{
	// User control code here, inside the loop
	startTask(runArm);
	startTask(claw);

	//Set arm mode to enable PID
	armMode = 1;

	//Create "deadzone" variables.
	int X2 = 0, Y1 = 0, X1 = 0, threshold = 30;

	while (true)
	{
		if(autoPilotActive==0){
			// This is the main execution loop for the user control program.
			// Each time through the loop your program should update motor + servo
			// values based on feedback from the joysticks.

			// ........................................................................
			// Insert user code here. This is where you use the joystick values to
			// update your motors, etc.
			// ........................................................................

			//Holonomic Drive Deadzone
			if(abs(C1LY) > threshold){
				Y1 = C1LY;
			}
			else{
				Y1 = 0;
			}
			if(abs(C1LX) > threshold){
				X1 = C1LX;
			}
			else{
				X1 = 0;
			}
			if(abs(C1RX) > threshold){
				X2 = C1RX;
			}
			else{
				X2 = 0;
			}

			//Holonomic Drive Function
			holonomicDrive(Y1,X1,X2);

			//Arm CHUCK
			if(vexRT[Btn7U] == 1)
			{
				target = chuckPOS;
			}
			//Arm UP
			else if(vexRT[Btn7L] == 1)
			{
				target = upPOS;
			}
			//Arm Down
			else if(vexRT[Btn7D] == 1)
			{
				target = downPOS;
			}

			//Toggle PID
			if(vexRT[Btn6U] == 1)
			{
				if(armMode==0){
					target = SensorValue[POT];
					armMode = 1;
				}
			}
			else if(vexRT[Btn6D] == 1)
			{
				if(armMode==1){
					armMode = 0;
				}
			}

			if(vexRT[Btn8U] == 1)
			{
				clawMode = 0;
			}
			else if(vexRT[Btn8D] == 1)
			{
				clawMode = 0;
			}

			if(vexRT[Btn8L] == 1)
			{
				startTask(autoPilot);
				autoPilotActive = 1;
			}
		}
		else{
			if(vexRT[Btn8R] == 1)
			{
				stopTask(autoPilot);
				autoPilotActive = 0;
			}
		}
		// Motor values can only be updated every 20ms
		wait1Msec(20);

	}
}
