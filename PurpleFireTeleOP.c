#pragma config(Sensor, in1,    POT,            sensorPotentiometer)
#pragma config(Motor,  port2,           RARMA,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           RARMB,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           LARMA,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           LARMB,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           FR,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           BR,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           FL,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           BL,            tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Controller 1/2, Stick L/R, Axis X/Y
#define C1LX vexRT[Ch4]
#define C1LY vexRT[Ch3]
#define C1RX vexRT[Ch1]
#define ARMUP vexRT[Btn6U]
#define ARMDOWN vexRT[ChBtn6D]

#define downPOS 4095
#define upPOS 3260
#define chuckPOS 2230

int armMode = 0;

float target, //the potentiometer value you want
error, //the difference between target and current
proportionalCoefficient, //what you multiply error by to get motor power
proportional, //P term, what you set motors to
motorPower; //what you set the motors to

//Task to Manage Arm Position
task runArm()
{
	target = downPOS;
	proportionalCoefficient = 0.5;

	while (true)
	{
		//ENABLE PID
		if(armMode==1){
			error = target - SensorValue[POT];
			proportional = error * proportionalCoefficient;
			motorPower = proportional;
			motor[RARMA] = motorPower;
			motor[RARMB] = motorPower;
			motor[LARMA] = motorPower;
			motor[LARMB] = motorPower;
		}
		//DISABLE PID
		else if(armMode==0){
			//Arm UP
			if(vexRT[Btn5U] == 1)
			{
				//Soft Limit For Going UP
				if(SensorValue[POT]>chuckPOS){
					motor[RARMA] = -127;
					motor[RARMB] = -127;
					motor[LARMA] = -127;
					motor[LARMB] = -127;
				}
				else{
					motor[RARMA] = 0;
					motor[RARMB] = 0;
					motor[LARMA] = 0;
					motor[LARMB] = 0;
				}
			}
			//Arm Down
			else if(vexRT[Btn5D] == 1)
			{
				//Soft Limit For Going DOWN
				if(SensorValue[POT]<downPOS){
					motor[RARMA] = 50;
					motor[RARMB] = 50;
					motor[LARMA] = 50;
					motor[LARMB] = 50;
				}
				else{
					motor[RARMA] = 0;
					motor[RARMB] = 0;
					motor[LARMA] = 0;
					motor[LARMB] = 0;
				}
			}
			//Arm Stop
			else{
				motor[RARMA] = 0;
				motor[RARMB] = 0;
				motor[LARMA] = 0;
				motor[LARMB] = 0;
			}
			// Motor values can only be updated every 20ms
			wait1Msec(20);
		}
	}
}

//Holonomic Drive using 3 Inputs
void holonomicDrive(int Y1,int X1,int X2)
{
	// Y component, X component, Rotation
	motor[FL] = -Y1 - X1 - X2;
	motor[FR] =  Y1 - X1 - X2;
	motor[BR] =  Y1 + X1 - X2;
	motor[BL] = -Y1 + X1 - X2;
}

task main()
{
	// User control code here, inside the loop
	startTask(runArm);
	//Set arm mode to enable PID
	armMode = 1;

	//Create "deadzone" variables.
	int X2 = 0, Y1 = 0, X1 = 0, threshold = 30;

	while (true)
	{
		// This is the main execution loop for the user control program.
		// Each time through the loop your program should update motor + servo
		// values based on feedback from the joysticks.

		// ........................................................................
		// Insert user code here. This is where you use the joystick values to
		// update your motors, etc.
		// ........................................................................

		//Holonomic Drive Deadzone
		if(abs(C1LY) > threshold){
			Y1 = C1LY;
		}
		else{
			Y1 = 0;
		}
		if(abs(C1LX) > threshold){
			X1 = C1LX;
		}
		else{
			X1 = 0;
		}
		if(abs(C1RX) > threshold){
			X2 = C1RX;
		}
		else{
			X2 = 0;
		}

		//Holonomic Drive Function
		holonomicDrive(Y1,X1,X2);

		//Arm CHUCK
		if(vexRT[Btn7U] == 1)
		{
			target = chuckPOS;
		}
		//Arm UP
		else if(vexRT[Btn7L] == 1)
		{
			target = upPOS;
		}
		//Arm Down
		else if(vexRT[Btn7D] == 1)
		{
			target = downPOS;
		}

		//Toggle PID
		if(vexRT[Btn6U] == 1)
		{
			if(armMode==0){
				target = SensorValue[POT];
				armMode = 1;
			}
		}
		else if(vexRT[Btn6D] == 1)
		{
			if(armMode==1){
				armMode = 0;
			}
		}

		// Motor values can only be updated every 20ms
		wait1Msec(20);

	}

}
