#pragma config(Sensor, in1,    POT,            sensorPotentiometer)
#pragma config(Sensor, in2,    GYRO,           sensorNone)
#pragma config(Motor,  port2,           ARMA,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           ARMB,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           FR,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           BR,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           FL,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           BL,            tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Controller 1/2, Stick L/R, Axis X/Y
#define C1LX vexRT[Ch4]
#define C1LY vexRT[Ch3]
#define C1RX vexRT[Ch1]
#define ARMUP vexRT[Btn6U]
#define ARMDOWN vexRT[ChBtn6D]

#define downPOS 2800
#define upPOS 1800
#define chuckPOS 875

float target, //the potentiometer value you want
error, //the difference between target and current
proportionalCoefficient, //what you multiply error by to get motor power
proportional, //P term, what you set motors to
motorPower; //what you set the motors to

task runArm()
{
	target = downPOS;
	proportionalCoefficient = 0.5;
	while (true)
	{
		error = target - SensorValue[POT];
		proportional = error * proportionalCoefficient;
		motorPower = proportional;
		motor[ARMA] = motorPower;
		motor[ARMB] = motorPower;
		// Motor values can only be updated every 20ms
		wait1Msec(20);
	}
}

task main()
{
	// User control code here, inside the loop
	startTask(runArm);

	while (true)
	{
		// This is the main execution loop for the user control program.
		// Each time through the loop your program should update motor + servo
		// values based on feedback from the joysticks.

		// ........................................................................
		// Insert user code here. This is where you use the joystick values to
		// update your motors, etc.
		// ........................................................................

		//Holonomic Drive
		// Y component, X component, Rotation
		motor[FL] = -C1LY - C1LX - C1RX;
		motor[FR] =  C1LY - C1LX - C1RX;
		motor[BR] =  C1LY + C1LX - C1RX;
		motor[BL] = -C1LY + C1LX - C1RX;

		//Arm CHUCK
		if(vexRT[Btn7U] == 1)
		{
			target = chuckPOS;
		}
		//Arm UP
		else if(vexRT[Btn7L] == 1)
		{
			target = upPOS;
		}
		//Arm Down
		else if(vexRT[Btn7D] == 1)
		{
			target = downPOS;
		}

		// Motor values can only be updated every 20ms
		wait1Msec(20);

	}

}
