#pragma config(Sensor, in1,    POT,            sensorPotentiometer)
#pragma config(Sensor, in2,    GYRO,           sensorNone)
#pragma config(Motor,  port2,           ARMA,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           ARMB,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           FR,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           BR,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           FL,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           BL,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           CLAW,          tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define downPOS 2800
#define upPOS 1800
#define chuckPOS 875

float target, //the potentiometer value you want
error, //the difference between target and current
proportionalCoefficient, //what you multiply error by to get motor power
proportional, //P term, what you set motors to
motorPower; //what you set the motors to

//Task to Manage Arm Position
task runArm()
{
	target = downPOS;
	proportionalCoefficient = 0.5;

	while (true)
	{
		error = target - SensorValue[POT];
		proportional = error * proportionalCoefficient;
		motorPower = proportional;
		motor[ARMA] = motorPower;
		motor[ARMB] = motorPower;
		// Motor values can only be updated every 20ms
		wait1Msec(20);
	}
}

//Holonomic Drive using 3 Inputs
void holonomicDrive(int Y1,int X1,int X2)
{
	// Y component, X component, Rotation
	motor[FL] = -Y1 - X1 - X2;
	motor[FR] =  Y1 - X1 - X2;
	motor[BR] =  Y1 + X1 - X2;
	motor[BL] = -Y1 + X1 - X2;
}

//Holonomic Drive Forward using speed Input
void holonomicForward(int speed)
{
	// Y component, X component, Rotation
	motor[FL] = -speed;
	motor[FR] =  speed;
	motor[BR] =  speed;
	motor[BL] = -speed;
}

//Holonomic Drive Backward using speed Input
void holonomicBackward(int speed)
{
	// Y component, X component, Rotation
	motor[FL] =  speed;
	motor[FR] = -speed;
	motor[BR] = -speed;
	motor[BL] =  speed;
}

//Holonomic Drive Left using speed Input
void holonomicLeft(int speed)
{
	// Y component, X component, Rotation
	motor[FL] = speed;
	motor[FR] = speed;
	motor[BR] = speed;
	motor[BL] = speed;
}

//Holonomic Drive Right using speed Input
void holonomicRight(int speed)
{
	// Y component, X component, Rotation
	motor[FL] = -speed;
	motor[FR] = -speed;
	motor[BR] = -speed;
	motor[BL] = -speed;
}

//Stop All Motors
void holonomicStop()
{
	motor[FL] = 0;
	motor[FR] = 0;
	motor[BR] = 0;
	motor[BL] = 0;
}

task main()
{
	startTask(runArm);

	clearDebugStream();

	while (true)
	{
		// update data
		writeDebugStreamLine("Value: %d ", SensorValue[POT]);
	}

}
