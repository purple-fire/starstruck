#pragma config(Sensor, in1,    POT,            sensorPotentiometer)
#pragma config(Motor,  port2,           RARMA,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           RARMB,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           LARMA,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           LARMB,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           FR,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           BR,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           FL,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           BL,            tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define downPOS 4095
#define upPOS 3260
#define chuckPOS 2230

float target, //the potentiometer value you want
error, //the difference between target and current
proportionalCoefficient, //what you multiply error by to get motor power
proportional, //P term, what you set motors to
motorPower; //what you set the motors to

//Task to Manage Arm Position
task runArm()
{
	target = downPOS;
	proportionalCoefficient = 0.5;

	while (true)
	{
		error = target - SensorValue[POT];
		proportional = error * proportionalCoefficient;
		motorPower = proportional;
		motor[RARMA] = motorPower;
		motor[RARMB] = motorPower;
		motor[LARMA] = motorPower;
		motor[RARMB] = motorPower;
		// Motor values can only be updated every 20ms
		wait1Msec(20);
	}
}

//Holonomic Drive using 3 Inputs
void holonomicDrive(int Y1,int X1,int X2, int seconds)
{
	// Y component, X component, Rotation
	motor[FL] = -Y1 - X1 - X2;
	motor[FR] =  Y1 - X1 - X2;
	motor[BR] =  Y1 + X1 - X2;
	motor[BL] = -Y1 + X1 - X2;
	wait1Msec(seconds*1000);
}

//Holonomic Drive Forward using speed Input
void holonomicForward(int speed, int seconds)
{
	// Y component, X component, Rotation
	motor[FL] = -speed;
	motor[FR] =  speed;
	motor[BR] =  speed;
	motor[BL] = -speed;
	wait1Msec(seconds*1000);
}

//Holonomic Drive Backward using speed Input
void holonomicBackward(int speed, int seconds)
{
	// Y component, X component, Rotation
	motor[FL] =  speed;
	motor[FR] = -speed;
	motor[BR] = -speed;
	motor[BL] =  speed;
	wait1Msec(seconds*1000);
}

//Holonomic Drive Left using speed Input
void holonomicLeft(int speed)
{
	// Y component, X component, Rotation
	motor[FL] = -speed;
	motor[FR] = speed;
	motor[BR] = -speed;
	motor[BL] = speed;
	wait1Msec(seconds*1000);
}

//Holonomic Drive Right using speed Input
void holonomicRight(int speed, int seconds)
{
	// Y component, X component, Rotation
	motor[FL] = speed;
	motor[FR] = -speed;
	motor[BR] = speed;
	motor[BL] = -speed;
	wait1Msec(seconds*1000);
}

//Holonomic Drive Rotate Left using speed Input
void holonomicRotateLeft(int speed)
{
	// Y component, X component, Rotation
	motor[FL] = speed;
	motor[FR] = speed;
	motor[BR] = speed;
	motor[BL] = speed;
	wait1Msec(seconds*1000);
}

//Holonomic Drive Rotate Right using speed Input
void holonomicRotateRight(int speed, int seconds)
{
	// Y component, X component, Rotation
	motor[FL] = -speed;
	motor[FR] = -speed;
	motor[BR] = -speed;
	motor[BL] = -speed;
	wait1Msec(seconds*1000);
}

//Stop All Motors
void holonomicStop()
{
	motor[FL] = 0;
	motor[FR] = 0;
	motor[BR] = 0;
	motor[BL] = 0;
}

task main()
{
	//Start Arm Management Task
	//startTask(runArm);

	//Go forward 2 seconds with 50 Power
	//holonomicForward(50,2);

	//Stop Holonomic
	holonomicStop();

	//DONE!
}
