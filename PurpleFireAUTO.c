#pragma config(Sensor, in1,    POT,            sensorPotentiometer)
#pragma config(Sensor, in2,    POTCLAW,        sensorPotentiometer)
#pragma config(Motor,  port1,           BL,            tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           RARMA,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           RARMB,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           LARMA,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           LARMB,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           FR,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           FL,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           CLAW1,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           CLAW2,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          BR,            tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define downPOS 4095
#define upPOS 3483
#define chuckPOS 2355
#define pushPOS 3150

#define clawOPEN 1120
#define clawCLOSE 367

float target, //the potentiometer value you want
error, //the difference between target and current
proportionalCoefficient, //what you multiply error by to get motor power
proportional, //P term, what you set motors to
motorPower; //what you set the motors to

float clawTarget;

//Task to Manage Arm Position
task runArm()
{
	target = downPOS;
	proportionalCoefficient = 0.5;

	while (true)
	{
		error = target - SensorValue[POT];
		proportional = error * proportionalCoefficient;
		motorPower = proportional;
		motor[RARMA] = motorPower;
		motor[RARMB] = motorPower;
		motor[LARMA] = motorPower;
		motor[RARMB] = motorPower;
		// Motor values can only be updated every 20ms
		wait1Msec(20);
	}
}

task claw()
{
	clawTarget = clawCLOSE;
	proportionalCoefficient = 0.5;

	while (true)
	{
		error = clawTarget - SensorValue[POTCLAW];
		proportional = error * proportionalCoefficient;
		motorPower = proportional;
		motor[RARMA] = motorPower;
		motor[RARMB] = motorPower;
		motor[LARMA] = motorPower;
		motor[RARMB] = motorPower;
		// Motor values can only be updated every 20ms
		wait1Msec(20);
	}
}

//Holonomic Drive using 3 Inputs
void holonomicDrive(int Y1,int X1,int X2, float seconds)
{
	// Y component, X component, Rotation
	motor[FL] = -Y1 - X1 - X2;
	motor[FR] =  Y1 - X1 - X2;
	motor[BR] =  Y1 + X1 - X2;
	motor[BL] = -Y1 + X1 - X2;
	wait1Msec(seconds*1000);
}

//Holonomic Drive Forward using speed Input
void holonomicForward(int speed, float seconds)
{
	// Y component, X component, Rotation
	motor[FL] = -speed;
	motor[FR] =  speed;
	motor[BR] =  speed;
	motor[BL] = -speed;
	wait1Msec(seconds*1000);
}

//Holonomic Drive Backward using speed Input
void holonomicBackward(int speed, float seconds)
{
	// Y component, X component, Rotation
	motor[FL] =  speed;
	motor[FR] = -speed;
	motor[BR] = -speed;
	motor[BL] =  speed;
	wait1Msec(seconds*1000);
}

//Holonomic Drive Left using speed Input
void holonomicRight(int speed, float seconds)
{
	// Y component, X component, Rotation
	motor[FL] = -speed;
	motor[FR] = -speed;
	motor[BR] = speed;
	motor[BL] = speed;
	wait1Msec(seconds*1000);
}

//Holonomic Drive Right using speed Input
void holonomicLeft(int speed, float seconds)
{
	// Y component, X component, Rotation
	motor[FL] = speed;
	motor[FR] = speed;
	motor[BR] = -speed;
	motor[BL] = -speed;
	wait1Msec(seconds*1000);
}

//Holonomic Drive Rotate Left using speed Input
void holonomicRotateLeft(int speed,float seconds)
{
	// Y component, X component, Rotation
	motor[FL] = speed;
	motor[FR] = speed;
	motor[BR] = speed;
	motor[BL] = speed;
	wait1Msec(seconds*1000);
}

//Holonomic Drive Rotate Right using speed Input
void holonomicRotateRight(int speed, float seconds)
{
	// Y component, X component, Rotation
	motor[FL] = -speed;
	motor[FR] = -speed;
	motor[BR] = -speed;
	motor[BL] = -speed;
	wait1Msec(seconds*1000);
}

//Stop All Motors
void holonomicStop()
{
	motor[FL] = 0;
	motor[FR] = 0;
	motor[BR] = 0;
	motor[BL] = 0;
}

task main()
{
	//Start Arm Management Task
	startTask(runArm);
	startTask(claw);
	//Push Off Center Stars

	target = downPOS;
	holonomicForward(110,1);
	holonomicBackward(110,1);
	holonomicStop();
	wait1Msec(2000);
	target = pushPOS;
	clawTarget = clawOPEN;
	wait1Msec(1000);

	//holonomicForward(110,.5);
	//holonomicStop();
	//wait1Msec(250);
	//holonomicRight(60,.5);
	//holonomicRotateLeft(25,.25);

	//Stop Holonomic
	holonomicStop();

	//Pickup Field stars

	//Stop Holonomic
	holonomicStop();

	//DONE!
}
